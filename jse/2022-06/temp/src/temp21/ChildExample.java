package temp21;

public class ChildExample {
	public static void main(String[] args) {
		//다형성-1: 부모타입의 참조변수에는 모든 자식 타입의 객체가 대입가능하다
		//자식 클래스는 부모가 물려준 메소드를 하나도 재정의(Overriding)하지 않고 있음.
		Parent parent = new Child();
		
		parent.field1 = "data1";	//부모타입의 필드값을 설정
		parent.method1();			//부모타입의 메소드 호출
		parent.method2();			//부모타입의 메소드 호출
		
		//자식 타입에서만 선언된 필드와 메소드를 사용
		//이유: 아무리 다형성-1에 의해서 부모타입의 참조변수에 자식객체가 실제 대입되어
		//		있어도 보이는 거라고는 부모밖에 보이지 않기 때문에 자식객체 입장에서는
		//		부모에게 물려받은 필드+메소드가 있고, 자기 자신만의 필드+메소드가 있는데
		//		부모밖에 보이지 않기 때문에 자식만의 필드+메소드는 아무리 자식 객체가 대입되어
		//		있어도 사용가능한 필드+메소드는 부모가 물려준 것밖에는 사용 못함.
//		parent.field2 = "data2";	//XX
//		parent.method3();			//XX
		
//		=================
//		부모 품에 안겨있는 (다형성-1) 자식 객체를 다시 원상태로 "끄집어" 내려면,
//		"강제 형변환"이 반드시 필요하다
//		언제 이런 강제 형변환이 필요한가? 다형성-1에 의해서 대입된 자식 객체만이 가지고 있는
//		필드+메소드를 사용해야 할 경우에 필요하다.
//		=================
		
		//다형성-1에서 다시 자식 객체로 환원시킴 by 강제 형변환
		Child child = (Child) parent;	//강제 형변환(상속 때문에 가능): 부모 품에서 강제로 빼냄.
		
		child.field2 = "yyy";	//OK
		child.method3();		//OK
		
//		---
		//부모한테서 끄집어 냈다고 상속 관계가 끊기는 게 아님.
		//부모가 물려준 모든 필드+메소드 역시 사용 가능
		child.field1 = "xxx";	//OK
		child.method1();		//OK
		child.method2();		//OK
	} //main
} //end class








